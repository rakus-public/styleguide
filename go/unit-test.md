# Unit Test

## 目次

1. この資料の概要
2. 単体テスト用のモックオブジェクト作成
3. 各レイヤーの単体テストにおけるモック化の方針

## 1.この資料の概要

- 各レイヤーにおける基本的な単体テストの記述方法とモックオブジェクトの作り方を記載する。

## 2.単体テスト用のモックオブジェクト作成

- 他のレイヤーのオブジェクトをフィールドに持っている場合、テスト対象の型以外のオブジェクトもちゃんと作る必要がある
  - たとえば、UserInterface 層のテストを動かすのに、 Infrastructure 層での DB の参照・更新もうまく動かせるようにしなければならない
- そのため、他レイヤーのオブジェクトをフィールドとして持つ struct の単体テストではモックオブジェクトを注入する

### 例： アプリケーションサービスの単体テストでのモックオブジェクト使用

- Application 層のアプリケーションサービスでは、エンティティの永続化・更新をするために Domain 層のリポジトリの interface をフィールドに持っている
- 実際に本番環境でアプリケーションを動かす場合は、Domain 層のリポジトリ interface を実装した infrastructure 層の実体をフィールドに代入する
  - [Dependency Injection の"AuthController 初期化関数作成"](./dependency-injection.md#authcontroller-初期化関数作成)の項を参照
- アプリケーションサービスの単体テストの場合は DB 接続まで含める必要はないので、リポジトリ interface のフィールドにはモックオブジェクトを代入する

### mockgen を使って gomock パッケージのモックオブジェクトを作成する

- Domain 層のリポジトリ interface のモックオブジェクトを作る必要がある
- `gomock`パッケージのモックオブジェクトを作る`mockgen`コマンドを利用する
- [認証 API のサンプルコード](./auth-api-sample-code.md)にある`src/authentication/domain/repositories.go`を以下のように書き換える
  - package 宣言よりも前に`go:generate`コメントを追加する
    - `mockgen`コマンドを実行
    - `-source`オプションに自身のファイル名を指定
    - `-destication`オプションにモックオブジェクトの宣言を出力するファイル名を指定
    - `-package`オプションに自身の属するパッケージ名を指定

```go
//go:generate mockgen -source=repositories.go -destination=repositories_mock.go -package=domain

package domain

import "context"

type AuthRepository interface {
    PasswordAuth(context.Context, UserID, Password) error
}
```

- `go generate`を実行すると以下のような`repositories_mock.go`が生成される
  - `MockAuthRepository`という実体のモックオブジェクトが作成される

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: repositories.go

// Package domain is a generated GoMock package.
package domain

import (
    context "context"
    reflect "reflect"

    gomock "github.com/golang/mock/gomock"
)

// MockAuthRepository is a mock of AuthRepository interface.
type MockAuthRepository struct {
    ctrl     *gomock.Controller
    recorder *MockAuthRepositoryMockRecorder
}

// MockAuthRepositoryMockRecorder is the mock recorder for MockAuthRepository.
type MockAuthRepositoryMockRecorder struct {
    mock *MockAuthRepository
}

// NewMockAuthRepository creates a new mock instance.
func NewMockAuthRepository(ctrl *gomock.Controller) *MockAuthRepository {
    mock := &MockAuthRepository{ctrl: ctrl}
    mock.recorder = &MockAuthRepositoryMockRecorder{mock}
    return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthRepository) EXPECT() *MockAuthRepositoryMockRecorder {
    return m.recorder
}

// PasswordAuth mocks base method.
func (m *MockAuthRepository) PasswordAuth(arg0 context.Context, arg1 UserID, arg2 Password) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "PasswordAuth", arg0, arg1, arg2)
    ret0, _ := ret[0].(error)
    return ret0
}

// PasswordAuth indicates an expected call of PasswordAuth.
func (mr *MockAuthRepositoryMockRecorder) PasswordAuth(arg0, arg1, arg2 interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PasswordAuth", reflect.TypeOf((*MockAuthRepository)(nil).PasswordAuth), arg0, arg1, arg2)
}
```

### gomock オブジェクトを使ったテストの基本的な書き方

```go
func TestAuthService_Auth(t *testing.T) {
    type fields struct {
        repo *domain.MockAuthRepository
        tx Transaction
    }

    // gomockのコントローラを生成
    ctrl := gomock.NewController(t)

    // モックオブジェクトのメソッドに渡す引数を作成
    argCtx := gomock.AssignableToTypeOf(reflect.TypeOf((*context.Context)(nil)).Elem())
    argUID := gomock.AssignableToTypeOf(domain.UserID("1"))
    argPW := gomock.AssignableToTypeOf(domain.Password("pass"))
    defaultErr := errors.New("error")

    tests := []struct {
        name          string
        fields        fields
        prepareFields func(f *fields)
        want          error
    }{
        {
            name:   "success",
            fields: fields{tx: NewMockTransaction()}, //Transactionをモック化
            prepareFields: func(f *fields) {
                f.repo = repository.NewMockBusinessDay(ctrl) //AuthRepositoryをモック化
                f.repo.EXPECT().PasswordAuth(argCtx, argUID, argPW).Return(nil) //PasswordAuthメソッドでエラーが発生しないよう指定
            },
            want: nil,
        },
        {
            name:   "error",
            fields: fields{tx: NewMockTransaction()}, //Transactionをモック化
            prepareFields: func(f *fields) {
                f.repo = repository.NewMockBusinessDay(ctrl) //AuthRepositoryをモック化
                f.repo.EXPECT().PasswordAuth(argCtx, argUID, argPW).Return(defaultErr) //PasswordAuthメソッドでエラーが発生するよう指定
            },
            want: defaultErr,
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // フィールドを準備
            tt.prepareFields(&tt.fields)
            s := &authService{
                repo: tt.fields.repo,
                tx: tt.fields.tx,
            }

            // テスト対象のメソッドを実行
            got := s.Auth(context.TODO(), "1", "pass")

            // 期待値との一致をチェック
            if tt.want == nil {
                assert.Nil(t, got)
            } else {
                assert.NotNil(t, got)
                assert.Equal(t, tt.want.Error(), got.Error())
            }
        })
    }
}
```

## 3.各レイヤーにおける単体テスト方針

- あくまでラクスの SRE 課における指針となるため、参考程度に捉えてください。

### 共通

- 単体テストは「Table Driven Test」で記述する

### UserInterface 層

- 依存する Application 層の アプリケーションサービス interface フィールドはモック化する

### Application 層

- 依存する Domain 層のリポジトリ interface フィールドはモック化する
- 依存する Application 層のトランザクション管理オブジェクトの interface フィールドはモック化する

### Infrastructure 層

- DB の参照・更新に関してはテストで検証する対象なのでモック化しない
- 外部 API 呼び出しの部品に依存する場合はモック化を検討する

### Domain 層

- テストスイート自身が持つデータやメソッドの引数の操作をするだけかので、Domain 層におけるテストでは基本的にはモック化はしない
- ただしデータ構造が複雑なドメインオブジェクトに依存している場合は、interface 化してモック化することを検討する余地あり

## 4.Tips

### Transaction のモック化について

- Application 層の`Transaction`(トランザクション管理オブジェクトの interface)のモック化は`mockgen`を使わず、自前で実装する
  - `Transaction#Transaction()`メソッドがモック化されてしまうと、アプリケーションサービスのメソッドでほぼ何も行われなくなるため
- `Transaction`のモック化は以下の例のような形で実装して`transaction_mock.go`として`application`パッケージに配置する

```go
package application

import "context"

type MockTransaction struct{}

func NewMockTransaction() *MockTransaction {
    return &MockTransaction{}
}

func (tx MockTransaction) Transaction(ctx context.Context, fn func(ctx context.Context) error) error {
    return fn(ctx)
}
```
